mlb11$runs[mlb11$at_bats == 5579]
y = -2789.2429 + 0.6305*5579
y
mlb11$runs[mlb11$at_bats == 5579]
y
728.3166-713
mlb11$runs[mlb11$at_bats == 5579]
713-728.3166
plot(m1$residuals ~ mlb11$at_bats)
abline(h = 0, lty = 3)  # adds a horizontal dashed line at y = 0
hist(m1$residuals)
qqnorm(m1$residuals)
qqline(m1$residuals)  # adds diagonal line to the normal prob plot
hist(m1$residuals)
plot(m1$residuals ~ mlb11$at_bats)
abline(h = 0, lty = 3)  # adds a horizontal dashed line at y = 0
head(data)
plot(data$wind, data$runs)
plot(data$wins, data$runs)
cor(mlb11$runs, mlb11$at_bats)^2
cor(mlb11$runs, mlb11$wins)^2
cor(mlb11$runs, mlb11$at_bars)^2
head(data)
cor(mlb11$runs, mlb11$at_bats)^2
cor(mlb11$runs, mlb11$hits)^2   ## 0.37
plot(data$hits, data$runs)
cor(mlb11$runs, mlb11$runs)^2   ## 0.37
cor(mlb11$runs, mlb11$wins)^2   ## 0.37
head(data)
cor(mlb11$runs, mlb11$bat_avg)^2   ## 0.37
cor(mlb11$runs, mlb11$hits)^2   ## 0.37
cor(mlb11$runs, mlb11$new_onbase)^2   ## 0.37
plot(data$new_onbase, data$runs)
plot(data$new_slug, data$runs)
cor(mlb11$runs, mlb11$new_slug)^2   ## 0.37
plot(data$new_obs, data$runs)
cor(mlb11$runs, mlb11$new_obs)^2   ## 0.37
cor(mlb11$runs, mlb11$at_bats)
plot(m1$residuals ~ mlb11$at_bats)
abline(h = 0, lty = 3)  # adds a horizontal dashed line at y = 0
sqrt(0.6)
sqrt(0.72)
0.54*5
qt(0.975)
qt(0.975, 27)
qt(0.975, 25)
qt(0.975, 23-2)
rm(list = ls())
setwd('/home/nozes/github-machine-learning-coursera/exercise4')
x = read.csv2('input/data1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
x <- as.matrix(sapply(x, as.numeric))
y = read.csv2('input/y.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)$V1
y <- as.matrix(sapply(y, as.numeric))
theta1 = read.csv2('input/theta1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta2 = read.csv2('input/theta2.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta1 <- as.matrix(sapply(theta1, as.numeric))
theta2 <- as.matrix(sapply(theta2, as.numeric))
### visualizing data
indexNumber <- 2010
digit <- matrix(as.numeric(matrix(x[indexNumber,], ncol = 20)), ncol=20)
rotate <- function(x) t(apply(x, 2, rev))
image(rotate(digit))
x <- cbind(rep(1, nrow(x)), x)
dim(x)
dim(t(theta1))
outputLayerOne <- hypothesis(theta1, x)
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
outputLayerOne <- hypothesis(theta1, x)
dim(outputLayerOne)
inputLayerTwo <- cbind(1, outputLayerOne)
dim(inputLayerTwo)
dim(t(theta2))
dim(inputLayerTwo)
dim(t(theta2))
m <- nrow(x)
m
hipo <- hypothesis(theta, x)
hipo <- hypothesis(theta2, x)
hypothesis <- function(x, theta) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
m <- nrow(inputLayerTwo)
hipo <- hypothesis(inputLayerTwo, theta2)
dim(hipoo)
dim(hipo)
dim(y)
y
y[,1]
dim(y)
vec <- rep(0, 10)
vec
x
5
vec[5]
vec[5] <- 1
vec
y[,1]
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- x
}
vec
}
createVectorForSinglePoint(10)
createVectorForSinglePoint(1)
createVectorForSinglePoint(4)
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- 1
}
vec
}
createVectorForSinglePoint(0)
createVectorForSinglePoint(1)
createVectorForSinglePoint(2)
createVectorForSinglePoint(3)
createVectorForSinglePoint(8)
createVectorForSinglePoint(9)
source('~/github-machine-learning-coursera/exercise4/functions4.R')
y
sapply(y, createVectorForSinglePoint)
matrix(NA, nrow = 5000, ncol=10)
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[1,]
yMatrix[500,]
yMatrix[501,]
dim(hipo)
dim(yMatrix)
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
dim(vectorCostForEachPoint)
head(vectorCostForEachPoint)
head(hipo)
dim(sum(vectorCostForEachPoint))
sum(vectorCostForEachPoint)
1/5000*sum(vectorCostForEachPoint)
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
rm(list = ls())
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
setwd('/home/nozes/github-machine-learning-coursera/exercise4')
x = read.csv2('input/data1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
x <- as.matrix(sapply(x, as.numeric))
y = read.csv2('input/y.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)$V1
y <- as.matrix(sapply(y, as.numeric))
theta1 = read.csv2('input/theta1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta2 = read.csv2('input/theta2.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta1 <- as.matrix(sapply(theta1, as.numeric))
theta2 <- as.matrix(sapply(theta2, as.numeric))
indexNumber <- 2010
digit <- matrix(as.numeric(matrix(x[indexNumber,], ncol = 20)), ncol=20)
rotate <- function(x) t(apply(x, 2, rev))
image(rotate(digit))
x <- cbind(rep(1, nrow(x)), x)
dim(x)
dim(t(theta1))
outputLayerOne <- hypothesis(theta1, x)
dim(outputLayerOne)
inputLayerTwo <- cbind(1, outputLayerOne)
dim(inputLayerTwo)
dim(t(theta2))
m <- nrow(inputLayerTwo)
hipo <- hypothesis(theta2, inputLayerTwo)
hipo
dim(hipo)
dim(y)
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
dim(hipo)
dim(yMatrix)
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
sum(vectorCostForEachPoint)
vectorCostForEachPoint
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
vectorCostForEachPoint
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
vectorCostForEachPoint
dim(hipo)
dim(yMatrix)
matrix(c(1, 2, 3, 4), ncol=2)
-matrix(c(1, 2, 3, 4), ncol=2)
-matrix(c(1, 2, 3, 4), ncol=2) * matrix(c(-1, -1, 0, 0), ncol=2)
yMatrix
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
dim(hipo)
dim(yMatrix)
yMatrix
indexNumber <- 2
digit <- matrix(as.numeric(matrix(x[indexNumber,], ncol = 20)), ncol=20)
rotate <- function(x) t(apply(x, 2, rev))
image(rotate(digit))
indexNumber <- 1
digit <- matrix(as.numeric(matrix(x[indexNumber,], ncol = 20)), ncol=20)
rotate <- function(x) t(apply(x, 2, rev))
image(rotate(digit))
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
vectorCostForEachPoint
sum(vectorCostForEachPoint)
1/5000*sum(vectorCostForEachPoint)
rm(list = ls())
setwd('/home/nozes/github-machine-learning-coursera/exercise4')
x = read.csv2('input/data1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
x <- as.matrix(sapply(x, as.numeric))
y = read.csv2('input/y.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)$V1
y <- as.matrix(sapply(y, as.numeric))
theta1 = read.csv2('input/theta1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta2 = read.csv2('input/theta2.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta1 <- as.matrix(sapply(theta1, as.numeric))
theta2 <- as.matrix(sapply(theta2, as.numeric))
### visualizing data
indexNumber <- 1
digit <- matrix(as.numeric(matrix(x[indexNumber,], ncol = 20)), ncol=20)
rotate <- function(x) t(apply(x, 2, rev))
image(rotate(digit))
x <- cbind(rep(1, nrow(x)), x)
dim(x)
dim(t(theta1))
outputLayerOne <- hypothesis(theta1, x)
dim(outputLayerOne)
inputLayerTwo <- cbind(1, outputLayerOne)
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
dim(x)
dim(t(theta1))
outputLayerOne <- hypothesis(theta1, x)
dim(outputLayerOne)
inputLayerTwo <- cbind(1, outputLayerOne)
dim(inputLayerTwo)
head(inputLayerTwo)
dim(inputLayerTwo)
dim(t(theta2))
m <- nrow(inputLayerTwo)
hipo <- hypothesis(theta2, inputLayerTwo)
dim(hipo)
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
head(yMatrix)
?head
hipo[1,]
hipo[1,] > 0.9
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[0] <- 1
} else {
vec[x] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
dim(yMatrix)
yMatrix[1,]
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- 1
}
vec
}
source('~/github-machine-learning-coursera/exercise4/functions4.R')
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[1,]
yMatrix[500,]
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[1] <- 1
} else {
vec[x+1] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[500,]
source('~/github-machine-learning-coursera/exercise4/functions4.R')
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[0] <- 1
} else {
vec[x+1] <- 1
}
vec
}
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[0] <- 1
} else {
vec[x] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[500,]
source('~/github-machine-learning-coursera/exercise4/functions4.R')
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
if(x==10) {
vec[9] <- 1
} else {
vec[x] <- 1
}
vec
}
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
dim(hipo)
dim(yMatrix)
yMatrix[500,]
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
vec[x] <- 1
vec
}
source('~/github-machine-learning-coursera/exercise4/functions4.R')
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[500,]
yMatrix[501,]
yMatrix[1001,]
yMatrix[5000,]
dim(hipo)
dim(yMatrix)
yMatrix[5000,]
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
sum(vectorCostForEachPoint)
1/5000*sum(vectorCostForEachPoint)
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
yMatrix[5000,]
yMatrix[0,]
yMatrix[1,]
yMatrix[1,]
yMatrix[500,]
yMatrix[501,]
rm(list = ls())
createVectorForSinglePoint <- function(x) {
vec <- rep(0, 10)
vec[x] <- 1
vec
}
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
setwd('/home/nozes/github-machine-learning-coursera/exercise4')
x = read.csv2('input/data1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
x <- as.matrix(sapply(x, as.numeric))
y = read.csv2('input/y.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)$V1
y <- as.matrix(sapply(y, as.numeric))
theta1 = read.csv2('input/theta1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta2 = read.csv2('input/theta2.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta1 <- as.matrix(sapply(theta1, as.numeric))
theta2 <- as.matrix(sapply(theta2, as.numeric))
x <- cbind(rep(1, nrow(x)), x)
dim(x)
dim(t(theta1))
outputLayerOne <- hypothesis(theta1, x)
dim(outputLayerOne)
inputLayerTwo <- cbind(1, outputLayerOne)
dim(inputLayerTwo)
dim(t(theta2))
m <- nrow(inputLayerTwo)
hipo
hipo <- hypothesis(theta2, inputLayerTwo)
dim(hipo)
yMatrix <- matrix(NA, nrow = 5000, ncol=10)
for(i in 1:5000) {
yMatrix[i, ] <- createVectorForSinglePoint(y[i])
}
dim(hipo)
dim(yMatrix)
yMatrix[501,]
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
sum(vectorCostForEachPoint)
1/5000*sum(vectorCostForEachPoint)
vectorCostForEachPoint <- NULL
yMatrix[1,]
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
vectorCostForEachPoint[1,]
vectorCostForEachPoint[1,] > 0.9
vectorCostForEachPoint[1,] < 1
yMatrix[1,]
vectorCostForEachPoint[2,] < 1
yMatrix[2,]
vectorCostForEachPoint[2,] < 1
yMatrix[501,]
vectorCostForEachPoint[501,] < 1
yMatrix[1001,]
vectorCostForEachPoint[1001,] < 1
-yMatrix
yMatrix[1001,]
vectorCostForEachPoint[1001,] < 1
yMatrix[nnn,]
nnn <- 1001
yMatrix[nnn,]
max(yMatrix[nnn,])
which(max(yMatrix[nnn,]) )
which.max(max(yMatrix[nnn,]) )
nnn <- 5000
which.max(max(yMatrix[nnn,]) )
which.index(max(yMatrix[nnn,]) )
nnn <- 5000
nnn
yMatrix[nnn,]
which.max(yMatrix[nnn,])
which.max(vectorCostForEachPoint[nnn,])
which.min(vectorCostForEachPoint[nnn,])
which.max(yMatrix[nnn,]) == which.min(vectorCostForEachPoint[nnn,])
acertou <- 0
for(nnn in 1:5000) {
if(which.max(yMatrix[nnn,]) == which.min(vectorCostForEachPoint[nnn,])) {
acertou <- acertou+1
}
}
acertou
4876/5000
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
dim(vectorCostForEachPoint)
vectorCostForEachPoint[1,]
vectorCostForEachPoint[1,] < 1
vectorCostForEachPoint[500,] < 1
vectorCostForEachPoint[501,] < 1
vectorCostForEachPoint[1001,] < 1
vectorCostForEachPoint[1501,] < 1
matrix(c(1, 2, 3, 4), nrow=2)
sum(matrix(c(1, 2, 3, 4), nrow=2))
vectorCostForEachPoint <- NULL
vectorCostForEachPoint <- -yMatrix*log(hipo) - (1-yMatrix)*log(hipo)
sum(vectorCostForEachPoint)
1/5000*sum(vectorCostForEachPoint)
vectorCostForEachPoint
vectorCostForEachPoint[1501,] < 1
source('~/github-machine-learning-coursera/exercise4/functions4.R')
cost <- function(x, y, theta) {
m <- nrow(x)
hipo <- hypothesis(theta, x)
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(hipo)
soma <- sum(vectorCostForEachPoint)
1/m * soma
}
source('~/github-machine-learning-coursera/exercise4/functions4.R')
