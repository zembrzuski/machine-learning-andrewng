thetas <- rbind(c(10, -20, -20))
input
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
thetasSecondLayer <- rbind(c(10, -20, -20))
hypothesis(input, thetasFirstLayer)
outputLayerOne <- hypothesis(input, thetasFirstLayer)
outputLayerOne
ouputLayerOne > 0.9
outputLayerOne > 0.9
outputLayerOne < 0.1
inputLayerTwo <- addBiasTherm(outputLayerOne)
inputLayerTwo
inputLayerTwo <- addBiasTherm(outputLayerOne)
inputLayerTwo
output <- hypothesis(inputLayerTwo, thetasSecondLayer)
output
output > 0.9
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
cost <- function(x, y, theta) {
m <- nrow(x)
hipo <- hypothesis(x, theta)
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(1-hipo)
1/m * sum(vectorCostForEachPoint)
}
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
inputLayerTwo
output
output>0.9
y <- rbind(c(1, 0, 0, 0))
y
cost(inputLayerTwo, y, thetasSecondLayer)
m <- nrow(x)
m <- nrow(inputLayerTwo)
m
inputLayerTwo
thetasSecondLayer
hipo <- hypothesis(inputLayerTwo, thetasSecondLayer)
hipo
dim(y)
dim(hipo)
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(1-hipo)
hipo
-y
y <- rbind(1, 0, 0, 0)
o
y
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(1-hipo)
vectorCostForEachPoint
vectorCostForEachPoint > 0.9
vectorCostForEachPoint < 0.1
sum(vectorCostForEachPoint)
cost(inputLayerTwo, y, thetasSecondLayer)
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
cost <- 0.1
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
cost < 0.1
cost < 1
cost < 0.9
cost < 0.5
cost < 0.4
cost < 0.2
cost < 0.1
y <- rbind(1, 0, 0, 1)
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
y <- rbind(1, 0, 0, 1)
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
cost
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
thetasSecondLayer <- rbind(c(10, -20, -20))
## propagation for the first layer
outputLayerOne <- hypothesis(input, thetasFirstLayer)
## propagation for the second layer
inputLayerTwo <- addBiasTherm(outputLayerOne)
output <- hypothesis(inputLayerTwo, thetasSecondLayer)
cost <- cost(inputLayerTwo, y, thetasSecondLayer)
print(cost)
output
y
y
errorLayer3 <- output - y
errorLayer3
thetasFirstLayer
errorLayer2 <- t(thetasFirstLayer)
t(thetasFirstLayer)
dim(t(thetasFirstLayer))
dim(errorLayer3)
dim(t(thetasSecondLayer))
dim(errorLayer3)
dim(thetasSecondLayer)
dim(errorLayer3)
rm(list=ls())
hypothesis <- function(x, theta) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
addBiasTherm <- function(x) {
cbind(rep(1, nrow(x)), x)
}
cost <- function(x, y, theta) {
m <- nrow(x)
hipo <- hypothesis(x, theta)
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(1-hipo)
1/m * sum(vectorCostForEachPoint)
}
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
thetasSecondLayer <- rbind(c(10, -20, -20))
outputLayerOne <- hypothesis(input, thetasFirstLayer)
inputLayerTwo <- addBiasTherm(outputLayerOne)
output <- hypothesis(inputLayerTwo, thetasSecondLayer)
output
y
output
ouput > 0.9
output > 0.9
y = rbind(1, 0, 0, 0)
errorLayer4 <- output - y
dim(t(thetasSecondLayer))
dim(errorLayer4)
dim(thetasSecondLayer)
dim(t(thetasSecondLayer))
dim(errorLayer4)
y = rbind(1, 0, 0, 0)
dim(y)
errorLayer4 <- output - y
errorLayer4
dim(errorLayer4)
errorLayer4 <- t(errorLayer4)
errorLayer4
dim(errorLayer4)
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
dim(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
thetasSecondLayer <- rbind(c(10, -20, -20))
outputLayerOne <- hypothesis(input, thetasFirstLayer)
inputLayerTwo <- addBiasTherm(outputLayerOne)
inputLayerTwo
dim(inputLayerTwo)
thetasSecondLayer <- rbind(c(10, -20, -20))
dim(thetasSecondLayer)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim(thetasFirstLayer)
rm(list=ls())
#rm(list = ls())
hypothesis <- function(x, theta) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
addBiasTherm <- function(x) {
cbind(rep(1, nrow(x)), x)
}
cost <- function(x, y, theta) {
m <- nrow(x)
hipo <- hypothesis(x, theta)
vectorCostForEachPoint <- -y*log(hipo) - (1-y)*log(1-hipo)
1/m * sum(vectorCostForEachPoint)
}
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
dim(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim(thetasFirstLayer)
thetasSecondLayer <- rbind(c(10, -20, -20))
dim(thetasSecondLayer)
## propagation for the first layer
outputLayerOne <- hypothesis(input, thetasFirstLayer)
## propagation for the second layer
inputLayerTwo <- addBiasTherm(outputLayerOne)
dim(inputLayerTwo)
output <- hypothesis(inputLayerTwo, thetasSecondLayer)
dim(outpu)
dim(output)
rm(list=ls())
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
dim(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim(thetasFirstLayer)
thetasSecondLayer <- rbind(c(10, -20, -20))
dim(thetasSecondLayer)
## propagation for the first layer
outputLayerOne <- hypothesis(input, thetasFirstLayer)
## propagation for the second layer
inputLayerTwo <- addBiasTherm(outputLayerOne)
dim(input)
dim(inputLayerTwo)
dim(output)
output <- hypothesis(inputLayerTwo, thetasSecondLayer)
dim(output)
rm(list=ls())
input <- rbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input <- addBiasTherm(input)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
input <- addBiasTherm(input)
dim(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim(thetasFirstLayer)
z <- input %*% t(thetasFirstLayer)
dim(z)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
rm(list=ls())
input <- cbind(
c(0, 0),
c(0, 1),
c(1, 0),
c(1, 1)
)
input
input <- addBiasTherm(input)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
input <- addBiasTherm(input)
input
dim(input)
thetasFirstLayer <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim
dim(thetasFirstLayer)
theta1 <- rbind(
c(-30, 20, 20),
c(-10, 20, 20)
)
dim(theta1)
theta2 <- rbind(c(10, -20, -20))
dim(theta2)
a1 = x
a2 = hypothesis(a1, theta1)
a1 = x
a2 = hypothesis(a1, theta1)
a1
a1 = x
a1 = input
a1
a2 = hypothesis(a1, theta1)
source('~/github-machine-learning-coursera/neural-network-recomecando/basefunctions.R')
a2 = hypothesis(a1, theta1)
a2 = hypothesis(theta1, a1)
a2
a2 = addBiasTherm(hypothesis(theta1, a1))
dim(a2)
a2
a3 = addBiasTherm(hypothesis(theta2, a2))
a3
a3 = hypothesis(theta2, a2)
a3
a3 > 0.9
y = cbind(c(1, 0, 0, 0))
y
y = rbind(c(1, 0, 0, 0))
y
output = rbind(c(1, 0, 0, 0))
y = output
error3 = a3 - y
error3 = a3 - y
error3
error2 = t(theta2)
t(theta2)
error2 = t(theta2) %*% error3 * (a2 * (1-a2))
error2
theta1
theta1
for(i in 1:nrow(theta1)) {
for(j in 1:ncol(theta1)) {
print(theta[i, j])
}
}
for(i in 1:nrow(theta1)) {
for(j in 1:ncol(theta1)) {
print(theta1[i, j])
}
}
for(i in 1:nrow(theta1)) {
for(j in 1:ncol(theta1)) {
print(a1[,j] * error2[i, ])
}
}
error2
for(i in 1:nrow(theta1)) {
for(j in 1:ncol(theta1)) {
print(a1[,j] * error2[i, ])
}
}
a1[,1]
error2[1,]
a1[1,]
error2[,1]
a1
error2
a1
a[,2]
a1[,2]
error[2,]
error2[2,]
c(4, 5) * c(2, -1)
c(4, 5) * c(2, -1, 0)
a1
error2
a1[,3]
error2[3,]
error2
a2[,1]
error3[1,]
22790/(22790+57737+7003)
1-(22790/(22790+57737+7003))
rm(list = ls())
addBiasThermFirstColumn <- function(x) {
cbind(rep(1, nrow(x)), x)
}
hypothesis <- function(theta, x) {
z <- x %*% t(theta)
1/(1+exp(-z))
}
createResultMatrix <- function(y) {
yMatrix <- matrix(NA, nrow=length(y), ncol=10)
for(i in 1:length(y)) {
pointVector <- rep(0, 10)
index <- y[i]
pointVector[index] <- 1
yMatrix[i,] <- pointVector
}
yMatrix
}
costFunction <- function(result, y) {
m <- nrow(result)
soma <- sum(-y*log(result) - (1-y)*log(1-result))
total <-  1/m * sum( soma    )
total
}
costFunctionWithRegularization <- function(result, y, theta1, theta2, lambda) {
m <- nrow(result)
soma <- sum(-y*log(result) - (1-y)*log(1-result))
newTheta1 <- theta1[,2:401]
newTheta2 <- theta2[,2:26]
regularization <- lambda/(2*m)  * (sum(newTheta1^2) + sum(newTheta2^2))
total <-  1/m * sum( soma    )   + regularization
total
}
setwd('/home/nozes/github-machine-learning-coursera/neural-network-vai-dar')
x = read.csv2('input/data1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
x <- as.matrix(sapply(x, as.numeric))
y = read.csv2('input/y.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)$V1
y <- as.matrix(sapply(y, as.numeric))
theta1 = read.csv2('input/theta1.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta2 = read.csv2('input/theta2.txt', sep=',', stringsAsFactors = FALSE, header = FALSE)
theta1 <- as.matrix(sapply(theta1, as.numeric))
theta2 <- as.matrix(sapply(theta2, as.numeric))
a1 <- addBiasThermFirstColumn(x)
a2 <- addBiasThermFirstColumn(hypothesis(theta1, a1))
a3 <- hypothesis(theta2, a2)
yMatrix <- createResultMatrix(y)
print(costFunction(a3, yMatrix))
print(costFunctionWithRegularization(a3, yMatrix, theta1, theta2, 1))
error3 = a3 - yMatrix
error2 = error3 %*% theta2 * (a2 * (1-a2))
error1 = error2 %*% theta1 * (a1 * (1-a1))
delta1 = t(error2) %*% a1
delta2 = t(error3) %*% a2
error3 = a3 - yMatrix
error2 = error3 %*% theta2 * (a2 * (1-a2))
delta1 = t(error2) %*% a1
delta2 = t(error3) %*% a2
der2 <- delta2/5000
der1 <- delta1/5000
epsilon <- 0.001
theta2PrimeiraParte <- theta2
theta2PrimeiraParte
epsilon <- 0.001
theta2PrimeiraParte <- theta2
theta2PrimeiraParte[5, 5] <- theta2PrimeiraParte[5, 5] + epsilon
resultPrimeiraParte <- hypothesis(theta2PrimeiraParte, a2)
theta2SegundaParte <- theta2
theta2SegundaParte[5, 5] <- theta2SegundaParte[5, 5] - epsilon
resultSegundaParte  <- hypothesis(theta2SegundaParte, a2)
(cost(resultPrimeiraParte,  yMatrix) - cost(resultSegundaParte, yMatrix)) / (2*epsilon)
(costFunction(resultPrimeiraParte,  yMatrix) - costFunction(resultSegundaParte, yMatrix)) / (2*epsilon)
der2[5,5]
epsilon <- 0.0001
theta2PrimeiraParte <- theta2
theta2PrimeiraParte[5, 5] <- theta2PrimeiraParte[5, 5] + epsilon
resultPrimeiraParte <- hypothesis(theta2PrimeiraParte, a2)
theta2SegundaParte <- theta2
theta2SegundaParte[5, 5] <- theta2SegundaParte[5, 5] - epsilon
resultSegundaParte  <- hypothesis(theta2SegundaParte, a2)
(costFunction(resultPrimeiraParte,  yMatrix) - costFunction(resultSegundaParte, yMatrix)) / (2*epsilon)
der2[5,5]
theta1PrimeiraParte <- theta1
theta1PrimeiraParte[5, 5] <- theta1PrimeiraParte[5, 5] + epsilon
resultPrimeiraParte <- hypothesis(theta1PrimeiraParte, a1)
resultA <- hypothesis(theta2, resultPrimeiraParte)
resultA <- hypothesis(theta2, addBiasThermFirstColumn(resultPrimeiraParte))
theta1SegundaParte <- theta1
theta1SegundaParte[5, 5] <- theta1SegundaParte[5, 5] - epsilon
resultSegundaParte <- hypothesis(theta1Segunda, a1)
resultB <- hypothesis(theta2, addBiasThermFirstColumn(resultSegundaParte))
epsilon <- 0.0001
theta1PrimeiraParte <- theta1
theta1PrimeiraParte[5, 5] <- theta1PrimeiraParte[5, 5] + epsilon
resultPrimeiraParte <- hypothesis(theta1PrimeiraParte, a1)
resultA <- hypothesis(theta2, addBiasThermFirstColumn(resultPrimeiraParte))
theta1SegundaParte <- theta1
theta1SegundaParte[5, 5] <- theta1SegundaParte[5, 5] - epsilon
resultSegundaParte <- hypothesis(theta1SegundaParte, a1)
resultB <- hypothesis(theta2, addBiasThermFirstColumn(resultSegundaParte))
(costFunction(resultA,  yMatrix) - costFunction(resultB, yMatrix)) / (2*epsilon)
der1[5,5]
der1[1,5]
der1[2,5]
der1[2,3]
max(der1)
der1
which.max(der1)
der1[3641]
max(der1)
max(der1)
which.max(der1)
ncol(der1)
3641/9
3641%9
der1[9,4]
der1[9,5]
der1
max(der1)
which(der1 == min(der1), arr.ind = TRUE)
which(der1 == max(der1), arr.ind = TRUE)
der1[3,134]
epsilon <- 0.0001
theta1PrimeiraParte <- theta1
theta1PrimeiraParte[3, 134] <- theta1PrimeiraParte[3, 134] + epsilon
resultPrimeiraParte <- hypothesis(theta1PrimeiraParte, a1)
resultA <- hypothesis(theta2, addBiasThermFirstColumn(resultPrimeiraParte))
theta1SegundaParte <- theta1
theta1SegundaParte[3, 134] <- theta1SegundaParte[3, 134] - epsilon
resultSegundaParte <- hypothesis(theta1SegundaParte, a1)
resultB <- hypothesis(theta2, addBiasThermFirstColumn(resultSegundaParte))
(costFunction(resultA,  yMatrix) - costFunction(resultB, yMatrix)) / (2*epsilon)
der1[3,134]
epsilon <- 0.00001
theta1PrimeiraParte <- theta1
theta1PrimeiraParte[3, 134] <- theta1PrimeiraParte[3, 134] + epsilon
resultPrimeiraParte <- hypothesis(theta1PrimeiraParte, a1)
resultA <- hypothesis(theta2, addBiasThermFirstColumn(resultPrimeiraParte))
theta1SegundaParte <- theta1
theta1SegundaParte[3, 134] <- theta1SegundaParte[3, 134] - epsilon
resultSegundaParte <- hypothesis(theta1SegundaParte, a1)
resultB <- hypothesis(theta2, addBiasThermFirstColumn(resultSegundaParte))
(costFunction(resultA,  yMatrix) - costFunction(resultB, yMatrix)) / (2*epsilon)
der1[3,134]
